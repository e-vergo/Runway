/-
Copyright (c) 2025 Runway contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
-/
import VersoPaper
import Runway.Config
import Runway.Graph
import Runway.Site
import Runway.Dress.Load
import Verso.Output.Html

/-!
# VersoPaper Integration for Runway

This module provides the integration between Runway and the VersoPaper genre,
enabling users to write papers in pure Verso markup that pull pre-built
artifacts from manifest.json.

## Usage

Papers can be written in `paper.lean` files using the VersoPaper genre:

```lean
import VersoPaper

open Verso.Genre.Paper

#doc (Paper) "My Paper Title" =>

:::paperFull "thm:main"

Some prose text explaining the theorem...

:::leanModule "MyProject.Theorems"
```

## Architecture

1. Dress generates artifacts during `lake build` (with BLUEPRINT_DRESS=1)
2. Artifacts are collected into `manifest.json`
3. Runway loads manifest.json and converts it to VersoPaper.Manifest format
4. VersoPaper's HTML renderer uses the manifest data to resolve placeholders
5. The final HTML is written to the output directory

## Integration Points

- `loadManifestFromDressed`: Loads manifest.json in VersoPaper format
- `buildManifestFromSite`: Converts Runway's BlueprintSite to VersoPaper.Manifest
- `resolvePlaceholders`: Post-processes HTML to replace placeholder divs with content
-/

namespace Runway.VersoPaper

-- Use qualified names to avoid namespace conflicts
open Verso.Output Html

/-!
## Manifest Conversion

Convert Runway's NodeInfo and site data to VersoPaper.Manifest format.
-/

/-- Convert Runway NodeStatus to VersoPaper status string -/
def nodeStatusToString : Runway.Graph.NodeStatus → String
  | .notReady => "notReady"
  | .ready => "ready"
  | .sorry => "sorry"
  | .proven => "proven"
  | .fullyProven => "fullyProven"
  | .mathlibReady => "mathlibReady"

/-- Convert a Runway NodeInfo to a VersoPaper.Manifest.Node -/
def nodeInfoToManifestNode (node : Runway.NodeInfo) : VersoPaper.Manifest.Node :=
  { label := node.label
    title := node.title
    envType := node.envType
    status := nodeStatusToString node.status
    statementHtml := node.statementHtml
    proofHtml := node.proofHtml
    signatureHtml := node.signatureHtml
    proofBodyHtml := node.proofBodyHtml
    declNames := node.declNames.map (·.toString)
    moduleName := node.moduleName
    uses := node.uses
    url := node.url
  }

/-- Convert Runway StatusCounts to VersoPaper StatusCounts -/
def statusCountsToManifest (sc : Runway.StatusCounts) : VersoPaper.Manifest.StatusCounts :=
  { notReady := sc.notReady
    ready := sc.ready
    «sorry» := sc.hasSorry
    proven := sc.proven
    fullyProven := sc.fullyProven
    mathlibReady := sc.mathlibReady
  }

/-- Convert Dress CheckResults to VersoPaper CheckResults -/
def checkResultsToManifest (cr : Dress.CheckResults) : VersoPaper.Manifest.CheckResults :=
  { connected := cr.isConnected
    componentCount := cr.numComponents
    componentSizes := cr.componentSizes
    cycles := cr.cycles
  }

/-- Build a VersoPaper Manifest from a BlueprintSite -/
def buildManifestFromSite (site : Runway.BlueprintSite) : VersoPaper.Manifest.Manifest :=
  let nodes := site.nodes.map nodeInfoToManifestNode
  let stats := match site.precomputedStats with
    | some sc => statusCountsToManifest sc
    | none => statusCountsToManifest site.computeStatusCounts
  let checkResults := match site.checks with
    | some cr => checkResultsToManifest cr
    | none => {}
  let keyTheorems := site.nodes.filter (·.keyDeclaration) |>.map (·.label)
  let messages := site.nodes.filterMap fun n =>
    n.message.map (n.label, ·)
  let projectNotes : VersoPaper.Manifest.ProjectNotes :=
    { blocked := site.nodes.filterMap fun n => n.blocked.map (n.label, ·)
      potentialIssues := site.nodes.filterMap fun n => n.potentialIssue.map (n.label, ·)
      technicalDebt := site.nodes.filterMap fun n => n.technicalDebt.map (n.label, ·)
      misc := site.nodes.filterMap fun n => n.misc.map (n.label, ·)
    }
  { nodes, stats, checkResults, keyTheorems, messages, projectNotes }

/-!
## Manifest Loading

Load manifest.json from the dressed directory and convert to VersoPaper format.
-/

/-- Load VersoPaper manifest from a dressed directory.
    This loads the manifest.json file generated by Dress. -/
def loadManifestFromDressed (dressedDir : System.FilePath) : IO VersoPaper.Manifest.Manifest := do
  let manifestPath := dressedDir / "manifest.json"
  if ← manifestPath.pathExists then
    VersoPaper.Manifest.Manifest.loadFromFile manifestPath
  else
    -- Return empty manifest if file doesn't exist
    pure {}

/-!
## HTML Rendering with Manifest

Functions to render VersoPaper documents with manifest data.
The key insight is that VersoPaper's GenreHtml creates placeholder divs
with `data-label` or `data-module` attributes. We post-process the HTML
to replace these placeholders with actual node content.
-/

/-- Render a node for paperStatement placeholder -/
def renderStatementPlaceholder (manifest : VersoPaper.Manifest.Manifest) (label : String) : Html :=
  match manifest.findNode? label with
  | some node => Verso.Genre.Paper.renderStatement node
  | none => Verso.Genre.Paper.renderMissing label

/-- Render a node for paperFull placeholder -/
def renderFullPlaceholder (manifest : VersoPaper.Manifest.Manifest) (label : String) : Html :=
  match manifest.findNode? label with
  | some node => Verso.Genre.Paper.renderFull node
  | none => Verso.Genre.Paper.renderMissing label

/-- Render a node for paperProof placeholder -/
def renderProofPlaceholder (manifest : VersoPaper.Manifest.Manifest) (label : String) : Html :=
  match manifest.findNode? label with
  | some node => Verso.Genre.Paper.renderProof node
  | none => Html.empty

/-- Render a single leanNode placeholder -/
def renderLeanNodePlaceholder (manifest : VersoPaper.Manifest.Manifest) (label : String) : Html :=
  match manifest.findNode? label with
  | some node => Verso.Genre.Paper.renderFull node
  | none => Verso.Genre.Paper.renderMissing label

/-- Render all nodes from a module for leanModule placeholder -/
def renderLeanModulePlaceholder (manifest : VersoPaper.Manifest.Manifest) (moduleName : String) : Html :=
  let nodes := manifest.findNodesByModule moduleName
  if nodes.isEmpty then
    Html.tag "div" #[("class", "lean-module-empty")] <|
      .text true s!"No nodes found in module {moduleName}"
  else
    Html.seq <| nodes.map Verso.Genre.Paper.renderFull

/-- Simple substring search returning byte offset -/
private def findSubstringFrom (s : String) (needle : String) (startByteIdx : Nat) : Option Nat := Id.run do
  let sBytes := s.utf8ByteSize
  let needleBytes := needle.utf8ByteSize
  if needleBytes == 0 then return some startByteIdx
  if startByteIdx + needleBytes > sBytes then return none

  -- Convert to list of bytes for searching
  let sData := s.toUTF8
  let needleData := needle.toUTF8

  for i in [startByteIdx : sBytes - needleBytes + 1] do
    let mut found := true
    for j in [0 : needleBytes] do
      if sData.get! (i + j) != needleData.get! j then
        found := false
        break
    if found then
      return some i

  return none

/-- Extract substring by byte indices -/
private def extractByteRange (s : String) (startByte : Nat) (endByte : Nat) : String :=
  let data := s.toUTF8
  let extracted := data.extract startByte endByte
  String.fromUTF8! extracted

/-- Replace placeholders in rendered HTML with actual node content.

    This function processes the HTML string looking for placeholder divs:
    - `<div class="paper-statement-placeholder" data-label="...">`
    - `<div class="paper-full-placeholder" data-label="...">`
    - `<div class="paper-proof-placeholder" data-label="...">`
    - `<div class="lean-node-placeholder" data-label="...">`
    - `<div class="lean-module-placeholder" data-module="...">`

    And replaces them with rendered content from the manifest.

    Note: This is a simplified string-based approach. The placeholders have a
    known structure from VersoPaper's GenreHtml instance, so we can process
    them reliably. -/
def resolvePlaceholders (manifest : VersoPaper.Manifest.Manifest) (html : String) : String := Id.run do
  let mut result := html

  -- Process each placeholder type
  result := processPlaceholder result "paper-statement-placeholder" "data-label" fun label =>
    (renderStatementPlaceholder manifest label).asString

  result := processPlaceholder result "paper-full-placeholder" "data-label" fun label =>
    (renderFullPlaceholder manifest label).asString

  result := processPlaceholder result "paper-proof-placeholder" "data-label" fun label =>
    (renderProofPlaceholder manifest label).asString

  result := processPlaceholder result "lean-node-placeholder" "data-label" fun label =>
    (renderLeanNodePlaceholder manifest label).asString

  result := processPlaceholder result "lean-module-placeholder" "data-module" fun modName =>
    (renderLeanModulePlaceholder manifest modName).asString

  return result
where
  /-- Process a single type of placeholder by finding and replacing all occurrences -/
  processPlaceholder (html : String) (className : String) (attrName : String)
      (render : String → String) : String := Id.run do
    let startMarker := s!"<div class=\"{className}\" {attrName}=\""
    let endMarker := "</div>"
    let mut result := html
    let mut searchStart : Nat := 0

    -- Keep searching for placeholders until none found
    while true do
      -- Find the start of a placeholder
      match findSubstringFrom result startMarker searchStart with
      | none => break
      | some startByte =>
        -- Find the attribute value (after the opening quote)
        let attrStartByte := startByte + startMarker.utf8ByteSize
        -- Find closing quote
        match findSubstringFrom result "\"" attrStartByte with
        | none => break
        | some attrEndByte =>
          -- Extract attribute value
          let attrValue := extractByteRange result attrStartByte attrEndByte

          -- Find the closing </div>
          match findSubstringFrom result endMarker attrEndByte with
          | none => break
          | some divEndByte =>
            let fullEndByte := divEndByte + endMarker.utf8ByteSize

            -- Render replacement content
            let replacement := render attrValue

            -- Replace the placeholder
            let before := extractByteRange result 0 startByte
            let after := extractByteRange result fullEndByte result.utf8ByteSize
            result := before ++ replacement ++ after

            -- Continue searching from after where we started
            searchStart := startByte + replacement.utf8ByteSize

    return result

/-!
## High-Level API

Functions for the main Runway CLI to use when processing paper.lean files.
-/

/-- Configuration for VersoPaper rendering -/
structure RenderConfig where
  /-- Path to the dressed artifacts directory -/
  dressedDir : System.FilePath
  /-- Output directory for generated HTML -/
  outputDir : System.FilePath
  /-- Base URL for links -/
  baseUrl : String := "/"
  /-- Paper title (fallback if not in document) -/
  title : String := "Paper"
  /-- Paper authors -/
  authors : Array String := #[]
  deriving Inhabited

/-- Result of paper rendering -/
structure RenderResult where
  /-- Path to the generated HTML file -/
  htmlPath : System.FilePath
  /-- Number of nodes resolved from manifest -/
  nodesResolved : Nat
  /-- Any warnings encountered -/
  warnings : Array String := #[]
  deriving Inhabited

/-- Check if a file path looks like a Verso paper (ends in .lean) -/
def isVersoPaper (path : System.FilePath) : Bool :=
  path.extension == some "lean"

end Runway.VersoPaper
