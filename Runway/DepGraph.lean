/-
Copyright (c) 2025 Runway contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
-/
import Lean
import Std.Data.HashMap
import Verso.Output.Html
import Runway.Config
import Runway.Site

/-!
# Dependency Graph Loading and Embedding

Loads SVG and JSON dependency graph files generated by Dress and embeds
them in the Blueprint HTML output with interactive controls.

## Files Expected from Dress

- `dep-graph.svg`: Visual representation of the dependency graph
- `dep-graph.json`: D3.js-compatible JSON data with layout information

## Integration

The SVG is embedded directly in the HTML with an interactive wrapper
providing pan, zoom, and navigation controls. The JSON data enables
JavaScript-based interactivity (highlighting, navigation, tooltips).
-/

namespace Runway.DepGraph

open Verso.Output Html

/-! ## File Loading -/

/-- Load the dependency graph SVG from the Dress build directory -/
def loadSvg (dressedDir : System.FilePath) : IO (Option String) := do
  let svgPath := dressedDir / "dep-graph.svg"
  if ← svgPath.pathExists then
    some <$> IO.FS.readFile svgPath
  else
    pure none

/-- Load the dependency graph JSON from the Dress build directory -/
def loadJson (dressedDir : System.FilePath) : IO (Option String) := do
  let jsonPath := dressedDir / "dep-graph.json"
  if ← jsonPath.pathExists then
    some <$> IO.FS.readFile jsonPath
  else
    pure none

/-- Load both SVG and JSON from the Dress build directory -/
def loadGraphFiles (dressedDir : System.FilePath) : IO (Option String × Option String) := do
  let svg ← loadSvg dressedDir
  let json ← loadJson dressedDir
  pure (svg, json)

/-! ## HTML Embedding -/

/-- Create the toolbar controls for the graph -/
private def graphToolbar : Html :=
  .tag "div" #[("class", "dep-graph-toolbar")] (
    .tag "button" #[("id", "graph-zoom-in"), ("title", "Zoom in"), ("aria-label", "Zoom in")]
      (.text true "+") ++
    .tag "button" #[("id", "graph-zoom-out"), ("title", "Zoom out"), ("aria-label", "Zoom out")]
      (.text true "\u2212") ++
    .tag "button" #[("id", "graph-fit"), ("title", "Fit to window"), ("aria-label", "Fit to window")]
      (.text true "Fit")
  )

/-- Compact legend for the dependency graph (static HTML, not in SVG) -/
private def graphLegendCompact : Html :=
  .tag "div" #[("class", "dep-graph-legend")] (
    .tag "div" #[("class", "legend-title")] (.text true "Legend") ++
    .tag "div" #[("class", "legend-items")] (
      -- Color status section (8 items)
      .tag "div" #[("class", "legend-item")] (
        .tag "span" #[("class", "legend-swatch not-ready")] Html.empty ++
        .tag "span" #[] (.text true "Not Ready")
      ) ++
      .tag "div" #[("class", "legend-item")] (
        .tag "span" #[("class", "legend-swatch stated")] Html.empty ++
        .tag "span" #[] (.text true "Stated")
      ) ++
      .tag "div" #[("class", "legend-item")] (
        .tag "span" #[("class", "legend-swatch ready")] Html.empty ++
        .tag "span" #[] (.text true "Ready")
      ) ++
      .tag "div" #[("class", "legend-item")] (
        .tag "span" #[("class", "legend-swatch sorry")] Html.empty ++
        .tag "span" #[] (.text true "Sorry (theorems only)")
      ) ++
      .tag "div" #[("class", "legend-item")] (
        .tag "span" #[("class", "legend-swatch proven")] Html.empty ++
        .tag "span" #[] (.text true "Proven/Defined")
      ) ++
      .tag "div" #[("class", "legend-item")] (
        .tag "span" #[("class", "legend-swatch fully-proven")] Html.empty ++
        .tag "span" #[] (.text true "Fully Proven (theorems only)")
      ) ++
      .tag "div" #[("class", "legend-item")] (
        .tag "span" #[("class", "legend-swatch mathlib-ready")] Html.empty ++
        .tag "span" #[] (.text true "Mathlib Ready")
      ) ++
      .tag "div" #[("class", "legend-item")] (
        .tag "span" #[("class", "legend-swatch in-mathlib")] Html.empty ++
        .tag "span" #[] (.text true "In Mathlib")
      ) ++
      -- Horizontal separator
      .tag "div" #[("class", "legend-separator")] Html.empty ++
      -- Shape section (2 items)
      .tag "div" #[("class", "legend-item")] (
        .tag "span" #[("class", "legend-shape ellipse")] Html.empty ++
        .tag "span" #[] (.text true "Theorems/Lemmas")
      ) ++
      .tag "div" #[("class", "legend-item")] (
        .tag "span" #[("class", "legend-shape box")] Html.empty ++
        .tag "span" #[] (.text true "Definitions")
      )
    )
  )

/-- Combined controls container (legend + toolbar) -/
private def graphControls : Html :=
  .tag "div" #[("class", "dep-graph-controls")] (
    graphLegendCompact ++
    graphToolbar
  )

/-- Embed the SVG in an interactive container -/
def embedSvg (svg : String) : Html :=
  .tag "div" #[("class", "dep-graph-container")] (
    graphToolbar ++
    .tag "div" #[("class", "dep-graph-viewport"), ("id", "dep-graph-viewport")] (
      .tag "div" #[("class", "dep-graph-svg"), ("id", "dep-graph")] (
        Html.text false svg
      )
    )
  )

/-- Embed graph JSON data for JavaScript interactivity -/
def embedJsonData (json : String) : Html :=
  .tag "script" #[("type", "application/json"), ("id", "dep-graph-data")] (
    Html.text false json
  )

/-- Embed both SVG and JSON data (if available) -/
def embedGraph (svg : Option String) (json : Option String) : Html :=
  let svgHtml := match svg with
    | some s => embedSvg s
    | none => .tag "div" #[("class", "dep-graph-container"), ("id", "dep-graph")]
        (.tag "p" #[("class", "dep-graph-placeholder")]
          (.text true "Dependency graph not available. Run Dress to generate."))
  let jsonHtml := match json with
    | some j => embedJsonData j
    | none => Html.empty
  jsonHtml ++ svgHtml

/-- Create the complete graph section with header -/
def graphSection (svg : Option String) (json : Option String) : Html :=
  .tag "section" #[("class", "graph-section"), ("id", "dependency-graph")] (
    .tag "h2" #[] (.text true "Dependency Graph") ++
    embedGraph svg json
  )

/-- Create a graph section for the home page with a link to the full page -/
def graphSectionWithLink (svg : Option String) (json : Option String) (toRoot : String) : Html :=
  .tag "section" #[("class", "graph-section"), ("id", "dependency-graph")] (
    .tag "div" #[("class", "graph-header")] (
      .tag "h2" #[] (.text true "Dependency Graph") ++
      .tag "a" #[("href", s!"{toRoot}dep_graph.html"), ("class", "graph-fullpage-link")]
        (.text true "View Full Page")
    ) ++
    embedGraph svg json
  )

/-- Create a link card for the dependency graph (no embedded graph) -/
def graphLinkCard (toRoot : String) : Html :=
  .tag "section" #[("class", "graph-section graph-link-card"), ("id", "dependency-graph")] (
    .tag "a" #[("href", s!"{toRoot}dep_graph.html"), ("class", "graph-card-link")] (
      .tag "div" #[("class", "graph-card")] (
        .tag "div" #[("class", "graph-card-icon")] (
          -- SVG graph icon
          .text false "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"48\" height=\"48\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"><circle cx=\"18\" cy=\"5\" r=\"3\"/><circle cx=\"6\" cy=\"12\" r=\"3\"/><circle cx=\"18\" cy=\"19\" r=\"3\"/><line x1=\"8.59\" y1=\"13.51\" x2=\"15.42\" y2=\"17.49\"/><line x1=\"15.41\" y1=\"6.51\" x2=\"8.59\" y2=\"10.49\"/></svg>"
        ) ++
        .tag "div" #[("class", "graph-card-content")] (
          .tag "h3" #[] (.text true "Dependency Graph") ++
          .tag "p" #[] (.text true "View the interactive dependency graph showing relationships between definitions and theorems.")
        ) ++
        .tag "div" #[("class", "graph-card-arrow")] (
          .text false "&rarr;"
        )
      )
    )
  )

/-- Create the legend for the dependency graph -/
private def graphLegend : Html :=
  .tag "div" #[("id", "Legend"), ("class", "graph-legend")] (
    .tag "span" #[("id", "legend_title"), ("class", "title")] (
      .text true "Legend" ++
      .tag "div" #[("class", "btn")] (
        .tag "div" #[("class", "bar")] Html.empty ++
        .tag "div" #[("class", "bar")] Html.empty ++
        .tag "div" #[("class", "bar")] Html.empty
      )
    ) ++
    .tag "dl" #[("class", "legend")] (
      .tag "dt" #[] (.text true "Boxes") ++
      .tag "dd" #[] (.text true "definitions") ++
      .tag "dt" #[] (.text true "Ellipses") ++
      .tag "dd" #[] (.text true "theorems and lemmas") ++
      .tag "dt" #[] (.text true "Blue border") ++
      .tag "dd" #[] (
        .text true "the " ++
        .tag "em" #[] (.text true "statement") ++
        .text true " of this result is ready to be formalized; all prerequisites are done"
      ) ++
      .tag "dt" #[] (.text true "Orange border") ++
      .tag "dd" #[] (
        .text true "the " ++
        .tag "em" #[] (.text true "statement") ++
        .text true " of this result is not ready to be formalized; the blueprint needs more work"
      ) ++
      .tag "dt" #[] (.text true "Blue background") ++
      .tag "dd" #[] (
        .text true "the " ++
        .tag "em" #[] (.text true "proof") ++
        .text true " of this result is ready to be formalized; all prerequisites are done"
      ) ++
      .tag "dt" #[] (.text true "Green border") ++
      .tag "dd" #[] (
        .text true "the " ++
        .tag "em" #[] (.text true "statement") ++
        .text true " of this result is formalized"
      ) ++
      .tag "dt" #[] (.text true "Green background") ++
      .tag "dd" #[] (
        .text true "the " ++
        .tag "em" #[] (.text true "proof") ++
        .text true " of this result is formalized"
      ) ++
      .tag "dt" #[] (.text true "Dark green background") ++
      .tag "dd" #[] (
        .text true "the " ++
        .tag "em" #[] (.text true "proof") ++
        .text true " of this result and all its ancestors are formalized"
      ) ++
      .tag "dt" #[] (.text true "Dark green border") ++
      .tag "dd" #[] (.text true "this is in Mathlib")
    )
  )

/-- Embed SVG in a full-viewport container for the dedicated page -/
def embedFullPageGraph (svg : Option String) (json : Option String) : Html :=
  let svgHtml := match svg with
    | some s =>
      .tag "div" #[("class", "dep-graph-wrapper")] (
        graphControls ++
        .tag "div" #[("class", "dep-graph-container dep-graph-fullpage")] (
          .tag "div" #[("class", "dep-graph-viewport"), ("id", "dep-graph-viewport"),
                       ("style", "height: 90vh;")] (
            .tag "div" #[("class", "dep-graph-svg"), ("id", "dep-graph")] (
              Html.text false s
            )
          )
        )
      )
    | none => .tag "div" #[("class", "dep-graph-container"), ("id", "dep-graph")]
        (.tag "p" #[("class", "dep-graph-placeholder")]
          (.text true "Dependency graph not available. Run Dress to generate."))
  let jsonHtml := match json with
    | some j => embedJsonData j
    | none => Html.empty
  jsonHtml ++ svgHtml

/-! ## Node Modal Generation -/

/-- Structure to hold basic node information extracted from JSON for modal generation.
    This is a minimal structure used only for JSON parsing; rich modals use pre-rendered HTML. -/
private structure JsonNodeInfo where
  id : String
  label : String
  envType : String  -- "theorem", "definition", "lemma", etc.
  url : String
  deriving Inhabited

/-- Extract a quoted string value after a key like "key": "value" -/
private def extractStringValue (s : String) (key : String) : Option String :=
  let keyPattern := s!"\"{key}\":"
  let parts := s.splitOn keyPattern
  if parts.length < 2 then none
  else
    let afterKey := parts[1]!
    -- Find the first quote after the key
    let quoteIdx := afterKey.splitOn "\""
    -- Pattern: whitespace, quote, value, quote
    -- After splitting on ", we get: [whitespace, value, rest...]
    if quoteIdx.length < 2 then none
    else some quoteIdx[1]!

/-- Parse a single node object from a JSON fragment -/
private def parseOneNode (fragment : String) : Option JsonNodeInfo := do
  let id ← extractStringValue fragment "id"
  let label := (extractStringValue fragment "label").getD id
  let envType := (extractStringValue fragment "envType").getD "theorem"
  let url := (extractStringValue fragment "url").getD s!"#{id}"
  some { id, label, envType, url }

/-- Parse the JSON data to extract basic node information -/
def parseJsonNodeInfo (json : String) : List JsonNodeInfo :=
  -- Split by "id": to find each node-like fragment
  let parts := json.splitOn "\"id\":"
  -- Skip the first part (before any "id":)
  let nodeParts := parts.drop 1
  -- Try to parse each fragment, keeping successes
  nodeParts.filterMap fun part => parseOneNode ("\"id\":" ++ part)

/-- Capitalize the first letter of a string -/
def capitalize (s : String) : String :=
  if s.isEmpty then s
  else
    let chars := s.toList
    match chars with
    | [] => s
    | c :: rest => String.ofList (c.toUpper :: rest)

/-- Generate a basic modal for a node (fallback when no rich content available) -/
def generateBasicNodeModal (node : JsonNodeInfo) : Html :=
  let envCapitalized := capitalize node.envType
  .tag "div" #[("class", "dep-modal-container"), ("id", s!"{node.id}_modal"), ("style", "display:none;")] (
    .tag "div" #[("class", "dep-modal-content")] (
      .tag "span" #[("class", "dep-closebtn")] (Html.text true "×") ++
      .tag "div" #[("class", "dep-modal-body")] (
        .tag "div" #[("class", "dep-modal-header")] (
          .tag "span" #[("class", "dep-modal-type")] (Html.text true envCapitalized) ++
          .tag "span" #[("class", "dep-modal-label")] (Html.text true s!" {node.label}")
        ) ++
        .tag "div" #[("class", "dep-modal-links")] (
          .tag "a" #[("class", "latex_link"), ("href", node.url)] (Html.text true "View in Blueprint")
        )
      )
    )
  )

/-- Generate the #statements container with all node modals (basic version from JSON) -/
def generateStatementsContainer (json : Option String) : Html :=
  match json with
  | none => .tag "div" #[("id", "statements"), ("style", "display:none;")] Html.empty
  | some j =>
    let nodes := parseJsonNodeInfo j
    let modals := nodes.map generateBasicNodeModal
    let combined := modals.foldl (· ++ ·) Html.empty
    .tag "div" #[("id", "statements"), ("style", "display:none;")] combined

/-- Generate the statements container with pre-rendered modal content (rich version) -/
def generateStatementsContainerFromHtml (modalsHtml : Html) : Html :=
  .tag "div" #[("id", "statements"), ("style", "display:none;")] modalsHtml

/-- Wrap a pre-rendered sbs-container in a modal structure -/
def wrapInModal (nodeId : String) (sbsContent : Html) (linkUrl : String) : Html :=
  .tag "div" #[("class", "dep-modal-container"), ("id", s!"{nodeId}_modal"), ("style", "display:none;")] (
    .tag "div" #[("class", "dep-modal-content")] (
      .tag "span" #[("class", "dep-closebtn")] (Html.text true "×") ++
      sbsContent ++
      .tag "div" #[("class", "dep-modal-links")] (
        .tag "a" #[("href", linkUrl)] (Html.text true "View in Blueprint →")
      )
    )
  )

/-! ## Full Page Generation -/

/-- Render sidebar navigation for the dependency graph page.
    Duplicated from Theme.lean to avoid circular imports. -/
private def renderDepGraphSidebar (chapters : Array ChapterInfo) (toRoot : String) (config : Config) : Html :=
  let homeItem := .tag "li" #[] (
    .tag "a" #[("href", s!"{toRoot}index.html")] (Html.text true "Blueprint Home")
  )

  -- Chapter items
  let chapterItems := chapters.map fun chapter =>
    let href := s!"{toRoot}{chapter.slug}.html"
    let chapterPrefix := if chapter.isAppendix then "Appendix" else s!"{chapter.number}."
    .tag "li" #[] (
      .tag "a" #[("href", href)] (Html.text true s!"{chapterPrefix} {chapter.title}")
    )

  -- Separator element
  let separator := .tag "li" #[("class", "nav-separator")] Html.empty

  -- Dependency graph link (current page, so active)
  let graphItem := .tag "li" #[("class", "active")] (
    .tag "a" #[("href", s!"{toRoot}dep_graph.html")] (Html.text true "Dependency Graph")
  )

  -- Paper link
  let paperItem := .tag "li" #[] (
    .tag "a" #[("href", s!"{toRoot}paper.html")] (Html.text true "Paper")
  )

  -- External links (GitHub, API Docs)
  let githubItem := match config.githubUrl with
    | some url => .tag "li" #[] (.tag "a" #[("href", url), ("target", "_blank")] (Html.text true "GitHub"))
    | none => Html.empty

  let docsItem := match config.docgen4Url with
    | some url => .tag "li" #[] (.tag "a" #[("href", url), ("target", "_blank")] (Html.text true "API Docs"))
    | none => Html.empty

  .tag "nav" #[("class", "toc")] (
    .tag "ul" #[("class", "sub-toc-0")] (
      .seq #[homeItem] ++ .seq chapterItems ++ .seq #[separator, graphItem, paperItem, separator, githubItem, docsItem]
    )
  )

/-- Create a full HTML page for the dependency graph with sidebar navigation.
    If `modalsHtml` is provided, uses rich sbs-container modals; otherwise falls back to JSON-based basic modals. -/
def fullPageGraph (svg : Option String) (json : Option String) (modalsHtml : Option Html)
    (_projectTitle : String) (chapters : Array ChapterInfo := #[]) (config : Option Config := none)
    (cssPath : String := "assets/blueprint.css") (jsPath : String := "assets/plastex.js")
    (versoJsPath : String := "assets/verso-code.js") : Html :=
  let mathjaxConfig := .tag "script" #[] (Html.text false r#"
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    };
  "#)

  -- Render sidebar if chapters and config are provided
  let toRoot := ""  -- dep_graph.html is at root level
  let sidebar := match config with
    | some cfg => renderDepGraphSidebar chapters toRoot cfg
    | none => Html.empty

  .tag "html" #[("lang", "en")] (
    .tag "head" #[] (
      .tag "meta" #[("charset", "UTF-8")] Html.empty ++
      .tag "meta" #[("name", "viewport"), ("content", "width=device-width, initial-scale=1")] Html.empty ++
      .tag "title" #[] (Html.text true "Dependency Graph") ++
      .tag "link" #[("rel", "stylesheet"), ("href", cssPath)] Html.empty ++
      .tag "link" #[("rel", "icon"), ("href", "data:,")] Html.empty ++
      mathjaxConfig ++
      .tag "script" #[("id", "MathJax-script"), ("async", ""),
                      ("src", "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js")] Html.empty ++
      .tag "script" #[("src", "https://unpkg.com/@popperjs/core@2")] Html.empty ++
      .tag "script" #[("src", "https://unpkg.com/tippy.js@6")] Html.empty ++
      .tag "link" #[("rel", "stylesheet"),
                    ("href", "https://unpkg.com/tippy.js@6/themes/light-border.css")] Html.empty ++
      .tag "script" #[("src", "https://cdn.jsdelivr.net/npm/marked/marked.min.js")] Html.empty
    ) ++
    .tag "body" #[("class", "dep-graph-page")] (
      -- Header matching plasTeX style
      .tag "header" #[] (
        .tag "nav" #[("class", "header")] (
          .tag "div" #[("class", "nav-wrapper")] (
            .tag "span" #[("id", "toc-toggle")] (Html.text true "☰")
          )
        )
      ) ++
      -- Main content wrapper with sidebar
      .tag "div" #[("class", "wrapper")] (
        sidebar ++
        .tag "div" #[("class", "content")] (
          -- Legend is now embedded in the SVG itself (top-left corner)
          embedFullPageGraph svg json ++
          -- Hidden modal containers for node details
          -- Use rich modals if provided, otherwise fall back to basic JSON-based modals
          (match modalsHtml with
           | some richModals => generateStatementsContainerFromHtml richModals
           | none => generateStatementsContainer json)
        )
      ) ++
      -- Scripts
      .tag "script" #[("src", "https://code.jquery.com/jquery-3.7.1.min.js"),
                      ("integrity", "sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo="),
                      ("crossorigin", "anonymous")] Html.empty ++
      .tag "script" #[("src", jsPath)] Html.empty ++
      .tag "script" #[("src", versoJsPath)] Html.empty
    )
  )

end Runway.DepGraph
